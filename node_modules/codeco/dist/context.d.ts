import { type Either } from "./either.js";
import type { NonEmptyArray } from "ts-essentials";
export type ANY = Codec<any, any, any>;
export type MIXED<T = any> = Codec<T, any, unknown>;
export type Refinement<A, B extends A> = (a: A) => a is B;
export type Predicate<A> = (a: A) => boolean;
export type Errors = Array<ValidationError>;
export type Validation<A> = Either<Errors, A>;
export type Trail = ReadonlyArray<TrailEntry>;
export type Is<A> = Refinement<unknown, A>;
export type Encode<A, O> = (a: A) => O;
export type Decode<I, A> = (input: I, context: Context) => Validation<A>;
export interface Decoder<I, A> {
    readonly name: string;
    decode: Decode<I, A>;
}
export interface TrailEntry {
    readonly key: string;
    readonly type: Decoder<any, any>;
    readonly actual: unknown;
}
export declare function getFunctionName(f: Function): string;
export declare function stringify(v: any): string;
export declare function getContextPath(trail: Trail): string;
export declare class ValidationError extends Error {
    readonly trail: Trail;
    constructor(trail: Trail, message?: string);
    get value(): unknown;
}
export interface Context {
    trail: Trail;
    success<TValue>(value: TValue): Validation<TValue>;
    failures<TValue>(errors: Errors): Validation<TValue>;
    failure<TValue>(message?: string): Validation<TValue>;
    child<TCodec extends ANY>(key: string, codec: TCodec, input: unknown): Context;
}
export type IContext = Context;
export declare function identity<T>(value: T): T;
export declare abstract class Codec<A, O = A, I = unknown> implements Decoder<I, A> {
    readonly _A: A;
    readonly _I: I;
    readonly _O: O;
    readonly name: string;
    protected constructor(name: string);
    abstract is(input: unknown): input is A;
    abstract encode(value: A): O;
    abstract decode(input: I, context: Context): Validation<A>;
    pipe<B, IB, A extends IB, OB extends A>(this: Type<A, O, I>, ab: Type<B, OB, IB>, name?: string): Type<B, O, I>;
    parse(input: I, context?: Context): A;
}
/**
 * Slight compatibility layer with io-ts codecs
 */
export declare class Type<A, O = A, I = unknown> extends Codec<A, O, I> {
    /** a unique name for this codec */
    readonly name: string;
    /** a custom type guard */
    readonly is: Is<A>;
    /** succeeds if a value of type I can be decoded to a value of type A */
    readonly decode: Decode<I, A>;
    /** converts a value of type A to a value of type O */
    readonly encode: Encode<A, O>;
    constructor(
    /** a unique name for this codec */
    name: string, 
    /** a custom type guard */
    is: Is<A>, 
    /** succeeds if a value of type I can be decoded to a value of type A */
    decode: Decode<I, A>, 
    /** converts a value of type A to a value of type O */
    encode: Encode<A, O>);
}
export declare class LazyContext implements Context {
    readonly trail: Trail;
    constructor(trail: Trail);
    static root<TInput, TValue>(codec: Decoder<TInput, TValue>, input: TInput): LazyContext;
    failures<TValue>(errors: Errors): Validation<TValue>;
    success<TValue>(value: TValue): Validation<TValue>;
    failure<TValue>(message?: string): Validation<TValue>;
    child<TCodec extends Decoder<any, any>>(key: string, codec: TCodec, input: unknown): Context;
}
export declare class ThrowContext implements Context {
    readonly trail: Trail;
    constructor(trail: Trail);
    static root<TInput, TValue>(codec: Decoder<TInput, TValue>, input: TInput): ThrowContext;
    failures<TValue>(errors: NonEmptyArray<ValidationError>): never;
    success<TValue>(value: TValue): Validation<TValue>;
    failure<TValue>(message?: string): never;
    child<TCodec extends Decoder<any, any>>(key: string, codec: TCodec, input: unknown): Context;
}
