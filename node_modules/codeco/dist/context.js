import { isLeft, left, right } from "./either.js";
export function getFunctionName(f) {
    return f.displayName || f.name || `<function${f.length}>`;
}
export function stringify(v) {
    if (typeof v === "function") {
        return getFunctionName(v);
    }
    if (typeof v === "number" && !isFinite(v)) {
        if (isNaN(v)) {
            return "NaN";
        }
        return v > 0 ? "Infinity" : "-Infinity";
    }
    return JSON.stringify(v);
}
export function getContextPath(trail) {
    return `/` + trail.map(({ key, type }) => `${key}(${type.name})`).join("/");
}
export class ValidationError extends Error {
    trail;
    constructor(trail, message = `Invalid value ${stringify(trail[trail.length - 1].actual)} supplied to ${getContextPath(trail)}`) {
        super(message);
        this.trail = trail;
    }
    get value() {
        return this.trail[this.trail.length - 1].actual;
    }
}
export function identity(value) {
    return value;
}
export class Codec {
    _A;
    _I;
    _O;
    name;
    constructor(name) {
        this.name = name;
    }
    pipe(ab, name = `${this.name}â†’${ab.name}`) {
        return new Type(name, ab.is, (i, c) => {
            const e = this.decode(i, c);
            if (isLeft(e)) {
                return e;
            }
            return ab.decode(e.right, c);
        }, this.encode === identity && ab.encode === identity ? identity : (b) => this.encode(ab.encode(b)));
    }
    parse(input, context = ThrowContext.root(this, input)) {
        const decodeResult = this.decode(input, context);
        if (isLeft(decodeResult))
            throw new Error(`Something is wrong: ${decodeResult} should be Right`);
        return decodeResult.right;
    }
}
/**
 * Slight compatibility layer with io-ts codecs
 */
export class Type extends Codec {
    name;
    is;
    decode;
    encode;
    constructor(
    /** a unique name for this codec */
    name, 
    /** a custom type guard */
    is, 
    /** succeeds if a value of type I can be decoded to a value of type A */
    decode, 
    /** converts a value of type A to a value of type O */
    encode) {
        super(name);
        this.name = name;
        this.is = is;
        this.decode = decode;
        this.encode = encode;
    }
}
export class LazyContext {
    trail;
    constructor(trail) {
        this.trail = trail;
    }
    static root(codec, input) {
        return new LazyContext([{ key: "", type: codec, actual: input }]);
    }
    failures(errors) {
        return left(errors);
    }
    success(value) {
        return right(value);
    }
    failure(message) {
        return left([new ValidationError(this.trail, message)]);
    }
    child(key, codec, input) {
        const nextTrail = this.trail.concat([{ key: key, type: codec, actual: input }]);
        return new LazyContext(nextTrail);
    }
}
export class ThrowContext {
    trail;
    constructor(trail) {
        this.trail = trail;
    }
    static root(codec, input) {
        return new ThrowContext([{ key: "", type: codec, actual: input }]);
    }
    failures(errors) {
        throw errors[0];
    }
    success(value) {
        return right(value);
    }
    failure(message) {
        throw new ValidationError(this.trail, message);
    }
    child(key, codec, input) {
        const nextTrail = this.trail.concat([{ key: key, type: codec, actual: input }]);
        return new ThrowContext(nextTrail);
    }
}
